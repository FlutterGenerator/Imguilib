#include <jni.h>
#include <pthread.h>
#include <android/input.h>
#include <cstdlib>
#include <iostream>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <sstream>
#include <iomanip>
#include <cctype>
#include <cstring> // for strcmp
#include <sstream>
#include <array>
#include <unistd.h>
#include <sys/system_properties.h>
#include <GLES3/gl3.h>
#include <EGL/egl.h>

#include "xdl.h"
#include "dobby.h"
#include "Include.h"
#include "imgui.h"
#include "imgui_internal.h"
#include "imgui_impl_opengl3.h"
#include "imgui_impl_android.h"
#include "Roboto-Regular.h"
#include "Icon.h"
#include "Iconcpp.h"
#include "Vector3.h"

#include "Il2Cpp/il2cpp_dump.h"

#include "include/Hook/KittyMemory/KittyMemory.h"
#include "include/Hook/KittyMemory/MemoryPatch.h"
#include "include/Hook/KittyMemory/KittyScanner.h"
#include "include/Hook/KittyMemory/KittyUtils.h"

#include "obfuscate.h"
#include "Utils.h"

std::vector<MemoryPatch> memoryPatches;
std::vector<uint64_t> offsetVector;

bool setup;
using namespace ImGui;

#define HOOKAF(ret, func, ...) \
    ret (*orig##func)(__VA_ARGS__); \
    ret my##func(__VA_ARGS__)

HOOKAF(void, Input, void *thiz, void *ex_ab, void *ex_ac) {
    origInput(thiz, ex_ab, ex_ac);
    ImGui_ImplAndroid_HandleInputEvent((AInputEvent*)thiz);
    return;
}

std::string GetProp(const char* key) {
    char value[PROP_VALUE_MAX];
    __system_property_get(key, value);
    return std::string(value);
}

int screenWidth;
int screenHeight;

int32_t (*orig_ANativeWindow_getWidth)(ANativeWindow* window);
int32_t _ANativeWindow_getWidth(ANativeWindow* window) {
	screenWidth = orig_ANativeWindow_getWidth(window);
	return orig_ANativeWindow_getWidth(window);
}

int32_t (*orig_ANativeWindow_getHeight)(ANativeWindow* window);
int32_t _ANativeWindow_getHeight(ANativeWindow* window) {
	screenHeight = orig_ANativeWindow_getHeight(window);
	return orig_ANativeWindow_getHeight(window);
}

bool esp = false;
bool drawEnemyBox = false;
ImVec4 espLineColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
static float espMaxDistance = 999.0f;
static float linePositionX = 0.5f;
std::vector<Vector3> espPoints;

void (*setpitchyaw)(float, float);
Vector3 (*WorldToScreenPoint)(void* instance, Vector3);
Vector3 (*get_position)(void* instance);
void* (*get_main)();
void* (*get_transform)(void* instance);
void (*old_Player_update)(void* player);

struct ESPBox {
    Vector3 top;
    Vector3 bottom;
};
std::vector<ESPBox> espBoxes;

void Player_update(void* player) {
    if (!player) return;

    void* transform = get_transform(player);
    Vector3 pos = get_position(transform);

   
    Vector3 bottomPos = { pos.x, pos.y, pos.z };
    Vector3 topPos = { pos.x, pos.y + 2.0f, pos.z };

    Vector3 screenBottom = WorldToScreenPoint(get_main(), bottomPos);
    Vector3 screenTop = WorldToScreenPoint(get_main(), topPos);

    if (screenBottom.z >= 1.0f && screenTop.z >= 1.0f) {
        screenBottom.y = screenHeight - screenBottom.y;
        screenTop.y = screenHeight - screenTop.y;
        espBoxes.push_back({ screenTop, screenBottom });
    }

    old_Player_update(player);
}

void DrawESP() {
    if (!esp || espBoxes.empty()) return;

    ImU32 espLineColorU32 = ImGui::ColorConvertFloat4ToU32(espLineColor);
    ImVec2 screenTopLine = ImVec2(screenWidth * linePositionX, 0.0f);
    auto* draw = ImGui::GetBackgroundDrawList();

    for (const auto& box : espBoxes) {
        if (box.bottom.z < 1.0f || box.top.z < 1.0f) continue;

        float boxHeight = fabsf(box.bottom.y - box.top.y);
        float boxWidth = boxHeight * 0.6f;

        ImVec2 boxMin = ImVec2(box.top.x - (boxWidth / 2), box.top.y);
        ImVec2 boxMax = ImVec2(box.top.x + (boxWidth / 2), box.top.y + boxHeight);

        if (drawEnemyBox)
            draw->AddRect(boxMin, boxMax, espLineColorU32, 0.0f, 15, 1.5f);
			
        draw->AddLine(screenTopLine, ImVec2(box.top.x, box.top.y), espLineColorU32, 2.0f);
    }

    espBoxes.clear();
}


// Our Menu
void DrawMenu() {
	auto il2cpp_handle = dlopen("libil2cpp.so", 4);
    const ImVec2 window_size = ImVec2(700, 600);
    ImGui::SetNextWindowSize(window_size, ImGuiCond_Once);
    ImGui::Begin("IMGUI MODMENU", nullptr, ImGuiWindowFlags_NoBringToFrontOnFocus);

    ImGui::SeparatorText("Unity <ESP>");
    ImGui::Checkbox("Enable Esp", &esp);
	ImGui::Checkbox("Draw Enemy Box", &drawEnemyBox);
	
	ImGui::SeparatorText("il2cpp <Dumper>");
	if (ImGui::Button("Dump IL2CPP",ImVec2(ImGui::GetContentRegionAvail().x, 0))) {
		if (il2cpp_handle) {
			il2cpp_dump(il2cpp_handle);
		}
	}

    ImGui::End();
}


void SetupImgui() {
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    ImGuiIO& io = ImGui::GetIO();
    int(*get_width)(void*);
    int(*get_height)(void*);
    get_width = (int (*)(void*)) Il2CppGetMethodOffset("UnityEngine.dll", "UnityEngine", "Screen", "get_width", 0);
    get_height = (int (*)(void*)) Il2CppGetMethodOffset("UnityEngine.dll", "UnityEngine", "Screen", "get_height", 0);
	io.DisplaySize = ImVec2((float)get_width(0), (float)get_height(0));
	ImGui::StyleColorsDark(); // Set a theme
	ImGuiStyle *style = &ImGui::GetStyle();
	
	style->Alpha = 1.0f;
	style->WindowTitleAlign = ImVec2(0.5, 0.5);
	style->PopupRounding = 3;
    style->WindowPadding = ImVec2(4, 4);
    style->FramePadding  = ImVec2(2, 2);
    style->ItemSpacing   = ImVec2(2, 2);
    style->ScrollbarSize = 17;
    style->WindowBorderSize = 1;
    style->ChildBorderSize  = 1;
    style->PopupBorderSize  = 3;
    style->FrameBorderSize  = 1;
    style->WindowRounding    = 3;
    style->ChildRounding     = 3;
    style->FrameRounding     = 3;
    style->ScrollbarRounding = 2;
    style->GrabRounding      = 3;
    ImGui_ImplOpenGL3_Init("#version 100");
	
    ImFontConfig font_cfg;
    io.Fonts->AddFontFromMemoryTTF(&Roboto_Regular, sizeof(Roboto_Regular), 40.0, &font_cfg, io.Fonts->GetGlyphRangesCyrillic());
    ImGui::GetStyle().ScaleAllSizes(3.0f);
}


bool clearMousePos = true;
struct UnityEngine_Vector2_Fields {
    float x;
    float y;
};

struct UnityEngine_Vector2_o {
    UnityEngine_Vector2_Fields fields;
};

enum TouchPhase {
    Began = 0,
    Moved = 1,
    Stationary = 2,
    Ended = 3,
    Canceled = 4
};

struct UnityEngine_Touch_Fields {
    int32_t m_FingerId;
    struct UnityEngine_Vector2_o m_Position;
    struct UnityEngine_Vector2_o m_RawPosition;
    struct UnityEngine_Vector2_o m_PositionDelta;
    float m_TimeDelta;
    int32_t m_TapCount;
    int32_t m_Phase;
    int32_t m_Type;
    float m_Pressure;
    float m_maximumPossiblePressure;
    float m_Radius;
    float m_fRadiusVariance;
    float m_AltitudeAngle;
    float m_AzimuthAngle;
};


EGLBoolean (*old_eglSwapBuffers)(EGLDisplay dpy, EGLSurface surface);
EGLBoolean hook_eglSwapBuffers(EGLDisplay dpy, EGLSurface surface) {
	
    static bool is_setup = false;
    static bool should_clear_mouse_pos = false;
	
    if (!is_setup) {
		SetupImgui();
        is_setup = true;
    }
	
    ImGuiIO &io = ImGui::GetIO();
    int (*TouchCount)(void*) = (int (*)(void*)) Il2CppGetMethodOffset("UnityEngine.dll", "UnityEngine", "Input", "get_touchCount", 0);
    int touchCount = TouchCount(nullptr);
    if (touchCount > 0) {
        UnityEngine_Touch_Fields touch = ((UnityEngine_Touch_Fields (*)(int)) Il2CppGetMethodOffset("UnityEngine.dll", "UnityEngine", "Input", "GetTouch", 1)) (0);
        float reverseY = io.DisplaySize.y - touch.m_Position.fields.y;

        switch (touch.m_Phase) {
            case TouchPhase::Began:
            case TouchPhase::Stationary:
                io.MousePos = ImVec2(touch.m_Position.fields.x, reverseY);
                io.MouseDown[0] = true;
                break;
            case TouchPhase::Ended:
            case TouchPhase::Canceled:
                io.MouseDown[0] = false;
                should_clear_mouse_pos = true;
                break;
            case TouchPhase::Moved:
                io.MousePos = ImVec2(touch.m_Position.fields.x, reverseY);
                break;
            default:
                break;
        }
    } else {
        io.MouseDown[0] = false;
    }
    ImGui_ImplOpenGL3_NewFrame();
    ImGui::NewFrame();
	DrawESP();
	DrawMenu();
	ImGui::Render();
    ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
    ImGui::EndFrame();
    if (should_clear_mouse_pos) {
        io.MousePos = ImVec2(-1, -1);
        should_clear_mouse_pos = false;
    }
    return old_eglSwapBuffers(dpy, surface);
}


void *imgui_go(void*) {
    void *handle_egl = xdl_open("libEGL.so", XDL_DEFAULT);
    void *handle_input = xdl_open("libinput.so", XDL_DEFAULT);
    
    void *xdl_sym_egl = xdl_sym(handle_egl, "eglSwapBuffers", nullptr);
    void *xdl_sym_input = xdl_sym(handle_input, "_ZN7android13InputConsumer21initializeMotionEventEPNS_11MotionEventEPKNS_12InputMessageE", nullptr);
    
	DobbyHook(xdl_sym_egl, (void*)hook_eglSwapBuffers, (void**)&old_eglSwapBuffers);
    DobbyHook(xdl_sym_input, (void*)myInput, (void**)&origInput);
    
	DobbyHook((void *) DobbySymbolResolver(OBFUSCATE("/system/lib/libandroid.so"), OBFUSCATE("ANativeWindow_getWidth")), (void *) _ANativeWindow_getWidth, (void **) &orig_ANativeWindow_getWidth);
	DobbyHook((void *) DobbySymbolResolver(OBFUSCATE("/system/lib/libandroid.so"), OBFUSCATE("ANativeWindow_getHeight")), (void *) _ANativeWindow_getHeight, (void **) &orig_ANativeWindow_getHeight);
	
    pthread_exit(nullptr);
}

void *hack_thread(void*) {
	do {
     sleep(1);
    } while (!isLibraryLoaded("libil2cpp.so"));
	
	WorldToScreenPoint = (Vector3(*)(void*, Vector3)) getAbsoluteAddress("libil2cpp.so", 0x5edd234);//Camera WorldToScreenPoint(Vector3 position)
    get_position = (Vector3 (*)(void *)) getAbsoluteAddress("libil2cpp.so", 0x5f33224);//Transform get_position
    get_transform = (void *(*)(void*)) getAbsoluteAddress("libil2cpp.so", 0x5f1f9e8);//Component get_transform
    get_main = (void*(*)()) getAbsoluteAddress("libil2cpp.so", 0x5edd4c4);//Camera get_main
    
    //private Void Update() { } //0x2e657b0
    DobbyHook((void *)getAbsoluteAddress("libil2cpp.so", 0x2e657b0), (void *) &Player_update, (void **) &old_Player_update);
	
	
    Il2CppAttach("libil2cpp.so");
    sleep(5);
	
	/*
	WorldToScreenPoint=(Vector3(*)(void*,Vector3))((uintptr_t)Il2CppGetMethodOffset(OBFUSCATE("UnityEngine.dll"),OBFUSCATE("UnityEngine"),OBFUSCATE("Camera"),OBFUSCATE("WorldToScreenPoint"),1));
	get_main=(void*(*)())((uintptr_t)Il2CppGetMethodOffset(OBFUSCATE("UnityEngine.dll"),OBFUSCATE("UnityEngine"),OBFUSCATE("Camera"),OBFUSCATE("get_main"),0));
	get_position=(Vector3(*)(void*))((uintptr_t)Il2CppGetMethodOffset(OBFUSCATE("UnityEngine.dll"),OBFUSCATE("UnityEngine"),OBFUSCATE("Transform"),OBFUSCATE("get_position"),0));
	get_transform=(void*(*)(void*))((uintptr_t)Il2CppGetMethodOffset(OBFUSCATE("UnityEngine.dll"),OBFUSCATE("UnityEngine"),OBFUSCATE("Component"),OBFUSCATE("get_transform"),0));
	DobbyHook(Il2CppGetMethodOffset(OBFUSCATE("Assembly-CSharp.dll"), OBFUSCATE(""), OBFUSCATE("PersonTarget"), OBFUSCATE("Update"), 0), (void*)Player_update, (void**)&old_Player_update);
	*/
	
	return nullptr; // same as pthread_exit(nullptr);
}

__attribute__((constructor))
void lib_main() {
    pthread_t hacks;
    pthread_create(&hacks, NULL, imgui_go, NULL);
    pthread_create(&hacks, NULL, hack_thread, NULL);
}

extern "C" jint JNIEXPORT JNI_OnLoad(JavaVM *vm, void *key) {
     jvm = vm;
    JNIEnv *env;
    vm->GetEnv((void**)&env, JNI_VERSION_1_6);
    return JNI_VERSION_1_6;
}
